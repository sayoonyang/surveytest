<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sticky Notes Wall</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
      background: #f9f9f9;
      overflow: hidden;
    }
    form {
      margin-bottom: 20px;
    }
    input {
      padding: 8px;
      font-size: 16px;
    }
    button {
      padding: 8px 12px;
      font-size: 16px;
    }
    #wall {
      position: relative;
      width: 100%;
      height: calc(100vh - 150px);
      border: 2px dashed #ccc;
      background-color: #fff;
    }
    .note {
      position: absolute;
      background: #fff176;
      padding: 10px 15px;
      width: 160px;
      min-height: 100px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      border-radius: 8px;
      cursor: grab;
      user-select: none;
    }
  </style>
</head>
<body>

  <h2>Drop your message ðŸ’¬</h2>
  <form id="messageForm">
    <input type="text" id="messageInput" placeholder="Type your message..." required />
    <button type="submit">Post</button>
  </form>

  <h3>Drag the notes around ðŸ‘‡</h3>
  <div id="wall"></div>

  <script>
    const form = document.getElementById('messageForm');
    const input = document.getElementById('messageInput');
    const wall = document.getElementById('wall');

    let zIndexCounter = 1;

    form.addEventListener('submit', e => {
      e.preventDefault();
      const message = input.value.trim();
      if (message) {
        const note = document.createElement('div');
        note.className = 'note';
        note.textContent = message;

        // Set a random position within the wall
        note.style.left = Math.random() * (wall.clientWidth - 180) + 'px';
        note.style.top = Math.random() * (wall.clientHeight - 120) + 'px';

        makeDraggable(note);
        wall.appendChild(note);
        input.value = '';
      }
    });

    function makeDraggable(element) {
      let offsetX, offsetY, isDragging = false;

      element.addEventListener('mousedown', (e) => {
        isDragging = true;
        offsetX = e.clientX - element.offsetLeft;
        offsetY = e.clientY - element.offsetTop;
        element.style.zIndex = ++zIndexCounter;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        element.style.left = (e.clientX - offsetX) + 'px';
        element.style.top = (e.clientY - offsetY) + 'px';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });

      // Touch support
      element.addEventListener('touchstart', (e) => {
        isDragging = true;
        const touch = e.touches[0];
        offsetX = touch.clientX - element.offsetLeft;
        offsetY = touch.clientY - element.offsetTop;
        element.style.zIndex = ++zIndexCounter;
      });

      document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        element.style.left = (touch.clientX - offsetX) + 'px';
        element.style.top = (touch.clientY - offsetY) + 'px';
      }, { passive: false });

      document.addEventListener('touchend', () => {
        isDragging = false;
      });
    }
  </script>

</body>
</html>
